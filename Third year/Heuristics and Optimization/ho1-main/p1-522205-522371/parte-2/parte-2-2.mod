# ------------------------------------------------------------------
# parte-2-2.mod
#
# cmnd: glpsol -m parte-2-2.mod -o solution.out -d datos.dat
# ------------------------------------------------------------------

# ----------------------
# SECCION DE PARAMETROS
# ----------------------

# Sets
set BUSES;          # autobuses 1..m
set FRANJAS;        # franjas 1..n
set TALLERES;       # talleres 1..u

# Disponibilidad: O[s, t] = 1 si la franja s está disponible en taller t
param O{FRANJAS,TALLERES}, integer, >= 0, <= 1;

# Pasajeros compartidos: matriz simétrica C[i,j], C[i,i]=0
param C{BUSES,BUSES}, integer, >= 0;

# ----------------------
# SECCION DE AUXILIARES
# ----------------------

# Conjuntos auxiliares
set PAIRS := {i in BUSES, j in BUSES: i < j};       # pares ordenados de autobuses distintos
set WORKPAIRS := {t1 in TALLERES, t2 in TALLERES: t1 <> t2};  # pares ordenados de talleres distintos

# Permitimos solo combinaciones factibles de (s,t1,t2): 
/*
 YAUX will be provided in the data file as a set of tuples
 (i,j,s,t1,t2) satisfying the feasibility conditions:
     (i,j) in PAIRS, s in FRANJAS, (t1,t2) in WORKPAIRS,
     O[s, t1] = 1, O[s, t2] = 1, C[i,j] > 0
 The use of setof() is not portable across all GLPK versions, so
 YAUX is read from the .dat generated by gen-2.py.
*/
set YAUX dimen 5;

# ---------------------
# SECCION DE VARIABLES
# ---------------------

var x{BUSES, FRANJAS, TALLERES}, binary;   # x[i,s,t] = 1 si autobús i asignado a franja s en taller t
var y{ (i,j,s,t1,t2) in YAUX }, binary;  # y = 1 si i en (s,t1) y j en (s,t2) con t1 != t2

# -------------------------
# SECCION FUNCION OBJETIVO
# -------------------------

# Minimizar usuarios afectados por asignaciones conflictivas
# (distintos talleres en misma franja horaria)
minimize z:
    sum{ (i,j,s,t1,t2) in YAUX } C[i,j] * y[i,j,s,t1,t2];

# -------------------------
# SECCION DE RESTRICCIONES
# -------------------------

# R1. Cada autobús asignado exactamente a una franja de algún taller disponible
s.t. assign_once{i in BUSES}:
    sum{ s in FRANJAS, t in TALLERES } x[i,s,t] = 1;

# R2. No asignar a franjas no disponibles
s.t. only_if_available{i in BUSES, s in FRANJAS, t in TALLERES}:
    x[i,s,t] <= O[s, t];

# R3. Cada franja en cada taller atiende como máximo un autobús
s.t. capacity{s in FRANJAS, t in TALLERES}:
    sum{ i in BUSES } x[i,s,t] <= 1;

# R4. Operador lógico AND aplicado a y[i,j,s,t1,t2] = x[i,s,t1] AND x[j,s,t2]
s.t. y_le_i{ (i,j,s,t1,t2) in YAUX }:
    y[i,j,s,t1,t2] <= x[i,s,t1];

s.t. y_le_j{ (i,j,s,t1,t2) in YAUX }:
    y[i,j,s,t1,t2] <= x[j,s,t2];

s.t. y_ge_sum{ (i,j,s,t1,t2) in YAUX }:
    y[i,j,s,t1,t2] >= x[i,s,t1] + x[j,s,t2] - 1;

end;
